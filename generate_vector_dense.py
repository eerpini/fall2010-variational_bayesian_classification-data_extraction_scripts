#!/usr/bin/python 

# this script will generate the vector for running the classification on 
# the number of components in the vector will be the number of elements in the data 
# input : without_permutations_unique.txt (after running "sort -u" on without_permutations.txt 
# input : elements.txt (generated by running list_elements.py on groups.txt)
# output : vector.txt
# the file vector.txt contains on each line, the label and the vector for that compound.
# the vector for each component element conatins the composition if it is present or else a 0

import sys
import string

if len(sys.argv) < 2:
	print "Specify the file with permutations and duplicated removed as input\n(without_permutations_unique.txt)\n"
	sys.exit(1)
element_file = file("elements.txt")
inf = file(sys.argv[1])
outf = file("vector_dense.txt", "w")
outf_binary = file("vector_binary_dense.txt", "w")
#initialize the list with elements to make it easier for creating the vectors
elements = []
for line in element_file:
	#list_elements.py adds a \n at the end of each line, we need to strip it
	line = line.rstrip("\n")
	elements.append(line)

# check if the list is fine 
print len(elements)
print elements

element_file.close()
# zero filling and creating a template to be used initially for every iteration
# note: the vectors will contain strings and not integer values of the compositions
num_elements = len(elements)
for line in inf:
	c1, c2, c3, e1, e2, e3, label, weight = line.split(" ")
	label=label[1:-1]
	#weight = weight[1:-1]
	#assigning the compositions in the vector
	vector = [ "0" for i in range(3)]
	if elements.count(e1)+elements.count(e2)+elements.count(e3) == 3:
		vector[0] = c1
		vector[1] = c2
		vector[2] = c3
		outf.write(label)
		outf_binary.write(label)
		for i in vector:
			if i!="0":
				outf_binary.write(" 1")
			else:
				outf_binary.write(" 0")
			outf.write(" "+str(i))
		outf.write("\n")
		outf_binary.write("\n")

inf.close()
outf.close()
outf_binary.close()
	

	




